



import { DigitalInvoice, InvoiceVATType } from "../business-invoice";
import { LegalEntity } from "../types-business";
import { IncomeTaxType, QuarterPeriod } from "./enums-finance";
import { Money } from "./finance-money";
import { DiscountSummary } from "./types-finance";
import { computeGraduatedIncomeTax } from "./utils-bir-tax";
import { getQuarterDateRange } from "./utils-finance";



export enum ReportStatus {
    /** Draft state, not yet finalized */
    DRAFT = "Draft",
    /** Approved by internal team or system */
    APPROVED = "Approved",
    /** Officially filed to BIR or governing body */
    FILED = "Filed",
    /** Archived for record-keeping, no longer active */
    ARCHIVED = "Archived",
    /** Invalidated due to error, duplication, or cancellation */
    VOID = "Void",
}

export interface TaxPayables {
    vat: Money;
    percentageTax: Money;
    withholdingTax: Money;
    incomeTax: Money;
}

/**
 * Aggregated totals for the reporting period (centavo precision via Money).
 */
export interface SummaryTotals {
    /** Gross sales for the period (usually VAT-inclusive if VAT‐registered) */
    sales: Money;

    /** Aggregated discount breakdown (SC/PWD, promos, etc.) */
    discounts: DiscountSummary;

    /** Sales returns or allowances (negative amounts) */
    returns: Money;

    /**
     * Taxable sales base:
     *   - VAT entity: salesVATable
     *   - Non-VAT entity: grossSales less discounts & returns
     */
    taxableSales: Money;

    /** Taxes due for the period (output VAT *or* percentage tax, plus WHT & income tax) */
    tax: TaxPayables;

    /**
     * Net sales (revenue after pulling out pass-through output-VAT *or*
     * after deducting percentage-tax expense).
     */
    netSales: Money;

    /**
     * Net income after:
     *   netSales – incomeTax
     * (Withholding tax is a credit, not an expense, so it is NOT subtracted here.)
     */
    netIncome: Money;
}



export interface InvoiceBreakdownItem {
    id: string;
    number: string;
    timestamp: string;
}


export interface ReportMetadata {
    /** Legal business name */
    companyName: string;
    /** Inclusive period start (ISO 8601 date) */
    periodStart: string;
    /** Inclusive period end (ISO 8601 date) */
    periodEnd: string;
    /** Quarter period (Q1–Q4) */
    quarter: QuarterPeriod;

    year: number;
    /** Currency code, e.g., "PHP" */
    currency: string;
    /** When the report was generated (ISO 8601 timestamp) */
    generatedAt: string;
    /** Username / system that generated the report */
    generatedBy: string;
    /** Semantic version of the report schema, useful for migrations */
    version: string;
    /** Number of invoices aggregated */
    invoiceCount: number;

    /** Income tax scheme applied by the business */
    incomeTaxType: IncomeTaxType;

    /** Username of the user that approved the report */
    approvedBy?: string;

    /** When the report was approved (ISO 8601 timestamp) */
    approvedAt?: string;
}



/**
 * Sales Summary Report class for aggregating invoice summaries and financial totals.
 * Links only basic invoice metadata for scalability.
 */
export class SalesSummaryReport {
    /** Unique identifier for the sales report */
    id: string;

    /** Report metadata including company name, period, currency, and generator info */
    metadata: ReportMetadata;


    /** Financial summary of all aggregated invoices for the report period */
    totals: SummaryTotals;

    /** Minimal invoice references bound to this report */
    invoices: InvoiceBreakdownItem[];

    /** ID of the user or account that owns or created this report */
    userID: string;

    /** Current report status (Draft, Approved, Filed, Archived, Void) */
    status: ReportStatus;

    /** Timestamp when this summary object was created */
    timestamp: string;


    /**
    * Creates a new SalesSummaryReport instance.
    *
    * @param id - Optional unique identifier for the sales report. If not provided, a slug-based ID is autogenerated.
    * @param metadata - Report metadata including company name, period, currency, and generator info.
    * @param totals - Financial summary of all aggregated invoices for the report period.
    * @param invoices - Minimal invoice references (IDs, numbers, timestamps) included in the summary.
    * @param userID - ID of the user or account that owns or created this report. Defaults to `"public-user"` if not provided.
    * @param status - Current report status (Draft, Approved, Filed, Archived, Void). Defaults to `ReportStatus.DRAFT`.
    * @param timestamp - Creation timestamp of the report (ISO 8601). Defaults to the current datetime.
    */
    constructor(
        id?: string,
        metadata?: ReportMetadata,
        totals?: SummaryTotals,
        invoices?: InvoiceBreakdownItem[],
        userID?: string,
        status: ReportStatus = ReportStatus.DRAFT,
        timestamp: string = new Date().toISOString()
    ) {
        this.id = id || autogenerateID(metadata?.companyName || "sales-summary");
        const defaultMetadata: ReportMetadata = {
            companyName: "Company XYZ",
            periodStart: new Date().toISOString().split("T")[0],
            periodEnd: new Date().toISOString().split("T")[0],
            quarter: QuarterPeriod.Q1,
            year: new Date().getFullYear(),
            currency: "PHP",
            generatedAt: new Date().toISOString(),
            generatedBy: userID || "SYSTEM",
            version: "1.0.0",
            invoiceCount: invoices?.length ?? 0,
            incomeTaxType: IncomeTaxType.GRADUATED
        };

        const defaultMoney: Money = new Money(0, "PHP");
        const defaultDiscounts: DiscountSummary = {
            scPWD: defaultMoney,
            other: defaultMoney,
            totalDiscount: defaultMoney,
        };
        const defaultTax: TaxPayables = {
            vat: defaultMoney,
            percentageTax: defaultMoney,
            withholdingTax: defaultMoney,
            incomeTax: defaultMoney,
        };
        const defaultTotals: SummaryTotals = {
            sales: defaultMoney,
            discounts: defaultDiscounts,
            returns: defaultMoney,
            taxableSales: defaultMoney,
            tax: defaultTax,
            netSales: defaultMoney,
            netIncome: defaultMoney,
        };
        this.metadata = metadata || defaultMetadata;
        this.totals = totals || defaultTotals;
        this.invoices = invoices || [];
        this.userID = userID || "public-user";
        this.status = status;
        this.timestamp = timestamp || new Date().toISOString();
    }




    /**
    * Initializes and creates a new `SalesSummaryReport` with default and null values.
    * @param taxpayer - Information about the Taxpayer including name, registered TIN, and business name.
    * @returns A new `SalesSummaryReport` instance.
    */
    static initialize(
        taxpayer: LegalEntity,
        userID: string,
        quarter: QuarterPeriod = QuarterPeriod.Q1,
        year: number = new Date().getFullYear(),
        incomeTaxType: IncomeTaxType = IncomeTaxType.GRADUATED,
    ): SalesSummaryReport {


        if (!taxpayer) {
            throw new Error('Taxpayer info is required to initialize .');
        }

        if (!userID || typeof userID !== 'string' || userID.trim() === "") {
            throw new Error("User ID must be a non-empty string.");
        }

        if (!taxpayer.name || typeof taxpayer.name !== 'string' || taxpayer.name.trim() === "") {
            throw new Error("Taxpayer's Legal Name must be a non-empty string.");
        }

        if (!taxpayer.tin || typeof taxpayer.tin !== 'string' || taxpayer.tin.trim() === "") {
            throw new Error("Taxpayer's Registered TIN must be a non-empty string.");
        }

        if (!taxpayer.address || typeof taxpayer.address !== 'string' || taxpayer.address.trim() === "") {
            throw new Error("Taxpayer's Legal Address must be a non-empty string.");
        }

        if (!taxpayer.businessName || typeof taxpayer.businessName !== 'string' || taxpayer.businessName.trim() === "") {
            throw new Error("Taxpayer's Business Name must be a non-empty string.");
        }

        const currentYear = new Date().getFullYear();
        const safeYear = typeof year === 'number' ? year : currentYear;

        if (safeYear < 1800 || safeYear > 3000) {
            throw new Error(`Invalid year: ${safeYear}. Year must be between 1800 and 3000.`);
        }


        const defaultMetadata: ReportMetadata = {
            companyName: taxpayer.businessName || "Company XYZ",
            periodStart: "", // will be set by autoSetQuarterAndPeriod
            periodEnd: "",   // will be set by autoSetQuarterAndPeriod
            quarter: quarter || QuarterPeriod.Q1, // default, but will be replaced
            year: safeYear || new Date().getFullYear(),
            currency: "PHP",
            generatedAt: new Date().toISOString(),
            generatedBy: userID || "SYSTEM",
            version: "1.0.0",
            invoiceCount: 0,
            incomeTaxType: incomeTaxType || IncomeTaxType.GRADUATED
        };

        // Instantiate the report
        const report = new SalesSummaryReport(
            undefined,
            defaultMetadata,
            undefined,
            [],
            userID,
            undefined,
            undefined
        );

        // Auto-set the correct quarter and date range
        return report.#autoSetQuarterAndPeriod(quarter, safeYear);
    }






    /**
      * Sets the company name for the report.
      * @param name - Company name (non-empty string).
      * @returns The updated instance.
      */
    setCompanyName(name: string): this {
        if (!name || typeof name !== 'string' || name.trim() === "") {
            throw new Error('Company name must be a non-empty string.');
        }
        this.metadata.companyName = name;
        return this;
    }

    /**
     * Sets the quarter period of the report.
     * @param quarter - Must be a valid QuarterPeriod enum value.
     * @returns The updated instance.
     */
    setQuarter(quarter: QuarterPeriod): this {
        if (!Object.values(QuarterPeriod).includes(quarter)) {
            throw new Error('Invalid quarter period.');
        }
        this.metadata.quarter = quarter;


        // Auto-sync periodStart & periodEnd with BIR quarter coverage.
        this.#autoSetPeriodRange();

        return this;
    }

    /**
     * Sets the currency for the report.
     * @param currency - Must be a valid non-empty string (e.g., "PHP", "USD").
     * @returns The updated instance.
     */
    setCurrency(currency: string): this {
        if (!currency || typeof currency !== 'string' || currency.trim() === "") {
            throw new Error('Currency must be a non-empty string.');
        }
        this.metadata.currency = currency.trim().toUpperCase();
        return this;
    }

    /**
     * Sets the income tax type.
     * @param taxType - Must be a valid IncomeTaxType enum value.
     * @returns The updated instance.
     */
    setIncomeTaxType(taxType: IncomeTaxType): this {
        if (!taxType || taxType.trim() === "") {
            throw new Error('Income Tax Type must be a non-empty string.');
        }
        this.metadata.incomeTaxType = taxType;
        return this;
    }

    /**
     * Sets the start period of the report.
     * @param dateStr - Must be a valid ISO date string.
     * @returns The updated instance.
     */
    setPeriodStart(dateStr: string): this {
        const date = new Date(dateStr);
        if (isNaN(date.getTime())) {
            throw new Error('Invalid start date. Must be a valid ISO string.');
        }
        this.metadata.periodStart = dateStr;
        return this;
    }

    /**
     * Sets the end period of the report.
     * @param dateStr - Must be a valid ISO date string.
     * @returns The updated instance.
     */
    setPeriodEnd(dateStr: string): this {
        const date = new Date(dateStr);
        if (isNaN(date.getTime())) {
            throw new Error('Invalid end date. Must be a valid ISO string.');
        }
        this.metadata.periodEnd = dateStr;
        return this;
    }

    /**
     * Approves the report and sets the approver's name.
     * @param approver - Must be a valid non-empty string.
     * @returns The updated instance.
     */
    approveReport(approver: string): this {
        if (!approver || typeof approver !== 'string' || approver.trim() === "") {
            throw new Error('Approver name must be a non-empty string.');
        }
        this.metadata.approvedBy = approver;
        this.metadata.approvedAt = new Date().toISOString();
        this.status = ReportStatus.APPROVED;
        return this;
    }

    /**
     * Files the report. Only allowed if report has been approved.
     * @returns The updated instance.
     */
    fileReport(): this {
        if (this.status !== ReportStatus.APPROVED) {
            throw new Error('Report must be approved before it can be filed.');
        }
        this.status = ReportStatus.FILED;
        return this;
    }

    /**
     * Archives the report.
     * @returns The updated instance.
     */
    archiveReport(): this {
        this.status = ReportStatus.ARCHIVED;
        return this;
    }

    /**
     * Voids the report. Cannot void a report that is already voided.
     * @returns The updated instance.
     */
    voidReport(): this {
        if (this.status === ReportStatus.VOID) {
            throw new Error('Report is already voided.');
        }
        this.status = ReportStatus.VOID;
        return this;
    }




    /**
    * Checks if an invoice with the given ID exists in the report.
    * @param invoiceID - The invoice ID to check.
    * @returns true if the invoice exists, false otherwise.
    */
    doesInvoiceExist(invoiceID: string): boolean {
        if (!invoiceID) return false;
        return this.invoices.some(invoice => invoice.id === invoiceID);
    }


    /**
    * Clears all existing invoices and resets the breakdown calculations.
    */
    clearInvoices(): this {
        this.invoices = [];
        this.metadata.invoiceCount = 0;
        this.#resetBreakdown();
        return this;
    }



    /**
     * Removes an invoice from the report by its invoiceNumber.
     * @param invoiceNumber - The unique invoice number to remove.
     * @returns The updated SalesSummaryReport instance.
     * @throws Error if invoiceNumber is not found, invalid, or the invoice list is empty.
     */
    removeInvoiceByNumber(invoiceNumber: string): this {
        if (!invoiceNumber || typeof invoiceNumber !== 'string' || invoiceNumber.trim() === '') {
            throw new Error("A valid non-empty invoiceNumber must be provided.");
        }

        if (!this.invoices || this.invoices.length === 0) {
            throw new Error("Invoice list is empty. Nothing to remove.");
        }

        const index = this.invoices.findIndex(
            (inv) => inv.number === invoiceNumber
        );

        if (index === -1) {
            throw new Error(`Invoice with number "${invoiceNumber}" not found.`);
        }

        this.invoices.splice(index, 1);
        this.metadata.invoiceCount = this.invoices.length;

        return this;
    }





    /**
    * Overwrites existing invoices with a new set, resets totals, and recomputes breakdown.
    * @param input - Array of DigitalInvoice objects to replace current invoices.
    * @returns this - For chaining.
    */
    updateInvoices(input: DigitalInvoice[]): this {
        if (!Array.isArray(input) || input.length === 0) {
            throw new Error("Input must be a non-empty array of DigitalInvoice objects.");
        }

        // Replace invoices with fresh minimal refs
        this.invoices = input.map(invoice => ({
            id: invoice.id,
            number: invoice.metadata.invoiceNumber.toUpperCase(),
            timestamp: invoice.timestamp,
        }));

        // Update invoice count
        this.metadata.invoiceCount = this.invoices.length;

        // Reset totals before recomputing
        this.#resetBreakdown();

        // Compute fresh totals based on new invoices
        this.#computeBreakdown(input);

        return this;
    }


    /**
       * Add digital invoices to the report and update computed totals.
       * @param input - Array of DigitalInvoice objects
       */
    addInvoices(input: DigitalInvoice[]): this {
        if (!Array.isArray(input) || input.length === 0) {
            throw new Error("Input must be a non-empty array of DigitalInvoice objects.");
        }

        const existingIDs = new Set(this.invoices.map(inv => inv.number.toUpperCase()));
        const newRefs = input
            .filter(invoice => !existingIDs.has(invoice.metadata.invoiceNumber.toUpperCase()))
            .map(invoice => ({
                id: invoice.id,
                number: invoice.metadata.invoiceNumber.toUpperCase(),
                timestamp: invoice.timestamp,
            }));


        this.invoices.push(...newRefs);
        this.metadata.invoiceCount = this.invoices.length;
        this.#computeBreakdown(input);
        return this;
    }

    /**
  * Compute period totals from a batch of DigitalInvoice objects.
  * Handles VAT vs non-VAT, graduated vs flat 8 % income-tax.
  */
    #computeBreakdown(invoices: DigitalInvoice[]) {
        let grossSales = 0;
        let discSC = 0;
        let discOther = 0;
        let vatOutput = 0;
        let pctTax = 0;
        let whtTax = 0;

        let salesVatableOrPT = 0;  // taxable-sales base

        for (const inv of invoices) {
            const b = inv.order.breakdown;
            const vatEntity = inv.metadata.type === InvoiceVATType.VAT;
            const nonVatEnt = inv.metadata.type === InvoiceVATType.NON_VAT;

            grossSales += b.totalSales;            // usually VAT-inclusive
            discSC += b.discount.scPWD;
            discOther += b.discount.other;
            whtTax += b.withholdingTax.totalWithheldTax;
            salesVatableOrPT += b.vat.salesVATable + b.salesPT; // your schema already splits these

            if (vatEntity) vatOutput += b.vat.totalVAT;
            else if (nonVatEnt) pctTax += b.percentageTax.totalPercentageTax;


        }

        const totalDiscounts = discSC + discOther;
        const grossLessDisc = grossSales - totalDiscounts;

        /* -----------------------------------------------------------
         *  income-tax base
         * -----------------------------------------------------------
         * For GRADUATED: we assume no additional OPEX/COGS deductions
         * For FLAT 8 %  : BIR rule = (gross receipts – 250 k) × 8 %
         * (computeGraduatedIncomeTax already handles both types)
         */
        const incomeTaxType = this.metadata.incomeTaxType || IncomeTaxType.GRADUATED;
        const incomeTax = computeGraduatedIncomeTax(grossLessDisc, incomeTaxType);

        console.log("Tax Type: ", incomeTaxType);

        /* -----------------------------------------------------------
         *  Net-sales and net-income logic
         * -----------------------------------------------------------
         *  - Pull out output-VAT from gross to get true revenue
         *  - Subtract percentage-tax if non-VAT (business expense)
         *  - Withholding tax is *not* an expense; it’s a credit.
         */
        let netSales = grossLessDisc;
        if (vatOutput) netSales -= vatOutput;   // remove pass-through VAT
        if (pctTax) netSales -= pctTax;      // percentage-tax expense

        const netIncome = netSales - incomeTax; // final profit

        const cur = this.metadata.currency;
        this.totals = {
            sales: new Money(grossSales, cur),
            discounts: {
                totalDiscount: new Money(totalDiscounts, cur),
                scPWD: new Money(discSC, cur),
                other: new Money(discOther, cur),
            },
            returns: new Money(0, cur),
            taxableSales: new Money(salesVatableOrPT, cur),
            tax: {
                vat: new Money(vatOutput, cur),
                percentageTax: new Money(pctTax, cur),
                withholdingTax: new Money(whtTax, cur),
                incomeTax: new Money(incomeTax, cur),
            },
            netSales: new Money(netSales, cur),
            netIncome: new Money(netIncome, cur),
        };
    }

    /**
    * Resets the financial summary totals to zero values.
    * Private method used internally before recalculations.
    */
    #resetBreakdown() {
        const cur = this.metadata.currency || "PHP";
        const zeroMoney = new Money(0, cur);
        this.totals = {
            sales: zeroMoney,
            discounts: {
                totalDiscount: zeroMoney,
                scPWD: zeroMoney,
                other: zeroMoney,
            },
            returns: zeroMoney,
            taxableSales: zeroMoney,
            tax: {
                vat: zeroMoney,
                percentageTax: zeroMoney,
                withholdingTax: zeroMoney,
                incomeTax: zeroMoney,
            },
            netSales: zeroMoney,
            netIncome: zeroMoney,
        };
    }



    /**
    * Automatically determines the current quarter based on today's date,
    * sets the quarter, and automatically populates the periodStart and periodEnd
    * fields according to BIR's standard quarter coverage.
    * @returns The updated instance. 
    */
    #autoSetQuarterAndPeriod(quarter?: QuarterPeriod, year?: number): this {
        // If quarter/year passed, update metadata first
        if (quarter) this.metadata.quarter = quarter;
        if (year) this.metadata.year = year;

        // Use your imported getQuarterDateRange helper
        const [startDate, endDate] = getQuarterDateRange(this.metadata.quarter, this.metadata.year);

        this.metadata.periodStart = startDate.toISOString().split('T')[0];
        this.metadata.periodEnd = endDate.toISOString().split('T')[0];

        return this;
    }



    /**
      * Derives periodStart and periodEnd based on the report's quarter,
      * using BIR-recognized quarter coverage:
      *   Q1: Jan-01 – Mar-31   (due May-15)
      *   Q2: Apr-01 – Jun-30   (due Aug-15)
      *   Q3: Jul-01 – Sep-30   (due Nov-15)
      *   Q4 / Annual: Oct-01 – Dec-31 (annual ITR due Apr-15 of following year)
      *
      * Year is taken from the CURRENT report metadata if available,
      * otherwise falls back to the current calendar year.
      */
    #autoSetPeriodRange(): void {
        const baseYear =
            this.metadata.year.toString() ??
            new Date().getFullYear().toString();

        switch (this.metadata.quarter) {
            case QuarterPeriod.Q1:
                this.metadata.periodStart = `${baseYear}-01-01`;
                this.metadata.periodEnd = `${baseYear}-03-31`;
                break;

            case QuarterPeriod.Q2:
                this.metadata.periodStart = `${baseYear}-04-01`;
                this.metadata.periodEnd = `${baseYear}-06-30`;
                break;

            case QuarterPeriod.Q3:
                this.metadata.periodStart = `${baseYear}-07-01`;
                this.metadata.periodEnd = `${baseYear}-09-30`;
                break;

            case QuarterPeriod.Q4: // annual coverage (Oct-Dec for Q4 view)
                this.metadata.periodStart = `${baseYear}-10-01`;
                this.metadata.periodEnd = `${baseYear}-12-31`;
                break;

            default:
                throw new Error("Unrecognized quarter period.");
        }
    }



    /**
      * Converts the current `SalesSummaryReport` class to a plain JSON object and automatically generates an ID.
      * @returns {object} - A plain JSON object representation of the `SalesSummaryReport` with an autogenerated ID.
      */
    finalize(approvedBy: string): object {
        this.status = ReportStatus.APPROVED;
        this.metadata.approvedBy = approvedBy;
        this.metadata.approvedAt = new Date().toISOString();
        return {
            id: autogenerateID(this.metadata.companyName),
            metadata: this.metadata,
            totals: this.totals,
            invoices: this.invoices,
            userID: this.userID,
            status: this.status,
            timestamp: this.timestamp
        };
    }


    /**
    * Converts the current `SalesSummaryReport` object to a plain JavaScript object (JSON).
    * @returns {object} - The plain object representation of the `SalesSummaryReport` instance.
    */
    toJSON(): object {

        return {
            id: this.id,
            metadata: this.metadata,
            totals: this.totals,
            invoices: this.invoices,
            userID: this.userID,
            status: this.status,
            timestamp: this.timestamp
        };
    }

    /**
    * Static method to parse a JSON string or object into a `SalesSummaryReport` instance.
    * 
    * @param json - A JSON string or plain object to be parsed.
    * @returns {SalesSummaryReport} - A new `SalesSummaryReport` instance based on the parsed JSON.
    * @throws Will throw an error if required properties are missing.
    */
    static parseFromJSON(json: string | object): SalesSummaryReport {
        const parsed = typeof json === 'string' ? JSON.parse(json) : json;

        if (!parsed.id) {
            throw new Error("Missing required property: 'id'");
        }

        if (!parsed.metadata || typeof parsed.metadata !== "object") {
            throw new Error("Missing or invalid report metadata.");
        }

        if (!parsed.metadata.quarter || !parsed.metadata.year) {
            throw new Error("Metadata must include both 'quarter' and 'year'.");
        }

        // Optional: validate required metadata fields more thoroughly
        const requiredMetadataFields = [
            "companyName",
            "periodStart",
            "periodEnd",
            "quarter",
            "year",
            "currency",
        ];

        for (const field of requiredMetadataFields) {
            if (!(field in parsed.metadata)) {
                throw new Error(`Missing required metadata field: ${field}`);
            }
        }

        const parsedTotals: SummaryTotals = {
            sales: Money.parseFromJSON(parsed.totals.sales),


            discounts: {
                scPWD: Money.parseFromJSON(parsed.totals.discounts.scPWD),
                other: Money.parseFromJSON(parsed.totals.discounts.other),
                totalDiscount: Money.parseFromJSON(parsed.totals.discounts.totalDiscount)
            },


            returns: Money.parseFromJSON(parsed.totals.returns),


            taxableSales: Money.parseFromJSON(parsed.totals.taxableSales),


            tax: {
                vat: Money.parseFromJSON(parsed.totals.tax.vat),
                percentageTax: Money.parseFromJSON(parsed.totals.tax.percentageTax),
                withholdingTax: Money.parseFromJSON(parsed.totals.tax.withholdingTax),
                incomeTax: Money.parseFromJSON(parsed.totals.tax.incomeTax),
            },


            netSales: Money.parseFromJSON(parsed.totals.netSales),

            netIncome: Money.parseFromJSON(parsed.totals.netIncome),

        };

        // Step 3: Create a new instance
        const report = new SalesSummaryReport(
            parsed.id,
            parsed.metadata,
            parsedTotals,
            parsed?.invoices || [],
            parsed?.userID,
            parsed?.status,
            parsed?.timestamp
        );

        return report;
    }



}


/**
 * Generates a unique ID based on a given input string and the current Unix timestamp.
 * Used as a fallback when no ID is provided for the sales report.
 *
 * @param input - Item name or any descriptive string to use in the ID.
 * @returns A unique string identifier in the format: `sreport-[slug]-[timestamp]`
 */
function autogenerateID(input: string): string {
    const unixTime = Math.floor(Date.now() / 1000);
    const titleText = input
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");

    return `sreport-${titleText}-${unixTime}`;
}
