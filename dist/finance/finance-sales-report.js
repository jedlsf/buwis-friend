"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SalesSummaryReport_instances, _SalesSummaryReport_computeBreakdown, _SalesSummaryReport_resetBreakdown, _SalesSummaryReport_autoSetQuarterAndPeriod, _SalesSummaryReport_autoSetPeriodRange;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SalesSummaryReport = exports.ReportStatus = void 0;
const business_invoice_1 = require("../business-invoice");
const enums_finance_1 = require("./enums-finance");
const finance_money_1 = require("./finance-money");
const utils_bir_tax_1 = require("./utils-bir-tax");
const utils_finance_1 = require("./utils-finance");
var ReportStatus;
(function (ReportStatus) {
    /** Draft state, not yet finalized */
    ReportStatus["DRAFT"] = "Draft";
    /** Approved by internal team or system */
    ReportStatus["APPROVED"] = "Approved";
    /** Officially filed to BIR or governing body */
    ReportStatus["FILED"] = "Filed";
    /** Archived for record-keeping, no longer active */
    ReportStatus["ARCHIVED"] = "Archived";
    /** Invalidated due to error, duplication, or cancellation */
    ReportStatus["VOID"] = "Void";
})(ReportStatus || (exports.ReportStatus = ReportStatus = {}));
/**
 * Sales Summary Report class for aggregating invoice summaries and financial totals.
 * Links only basic invoice metadata for scalability.
 */
class SalesSummaryReport {
    /**
    * Creates a new SalesSummaryReport instance.
    *
    * @param id - Optional unique identifier for the sales report. If not provided, a slug-based ID is autogenerated.
    * @param metadata - Report metadata including company name, period, currency, and generator info.
    * @param totals - Financial summary of all aggregated invoices for the report period.
    * @param invoices - Minimal invoice references (IDs, numbers, timestamps) included in the summary.
    * @param userID - ID of the user or account that owns or created this report. Defaults to `"public-user"` if not provided.
    * @param status - Current report status (Draft, Approved, Filed, Archived, Void). Defaults to `ReportStatus.DRAFT`.
    * @param timestamp - Creation timestamp of the report (ISO 8601). Defaults to the current datetime.
    */
    constructor(id, metadata, totals, invoices, userID, status = ReportStatus.DRAFT, timestamp = new Date().toISOString()) {
        _SalesSummaryReport_instances.add(this);
        this.id = id || autogenerateID(metadata?.companyName || "sales-summary");
        const defaultMetadata = {
            companyName: "Company XYZ",
            periodStart: new Date().toISOString().split("T")[0],
            periodEnd: new Date().toISOString().split("T")[0],
            quarter: enums_finance_1.QuarterPeriod.Q1,
            year: new Date().getFullYear(),
            currency: "PHP",
            generatedAt: new Date().toISOString(),
            generatedBy: userID || "SYSTEM",
            version: "1.0.0",
            invoiceCount: invoices?.length ?? 0,
            incomeTaxType: enums_finance_1.IncomeTaxType.GRADUATED
        };
        const defaultMoney = new finance_money_1.Money(0, "PHP");
        const defaultDiscounts = {
            scPWD: defaultMoney,
            other: defaultMoney,
            totalDiscount: defaultMoney,
        };
        const defaultTax = {
            vat: defaultMoney,
            percentageTax: defaultMoney,
            withholdingTax: defaultMoney,
            incomeTax: defaultMoney,
        };
        const defaultTotals = {
            sales: defaultMoney,
            discounts: defaultDiscounts,
            returns: defaultMoney,
            taxableSales: defaultMoney,
            tax: defaultTax,
            netSales: defaultMoney,
            netIncome: defaultMoney,
        };
        this.metadata = metadata || defaultMetadata;
        this.totals = totals || defaultTotals;
        this.invoices = invoices || [];
        this.userID = userID || "public-user";
        this.status = status;
        this.timestamp = timestamp || new Date().toISOString();
    }
    /**
    * Initializes and creates a new `SalesSummaryReport` with default and null values.
    * @param taxpayer - Information about the Taxpayer including name, registered TIN, and business name.
    * @returns A new `SalesSummaryReport` instance.
    */
    static initialize(taxpayer, userID, quarter = enums_finance_1.QuarterPeriod.Q1, year = new Date().getFullYear(), incomeTaxType = enums_finance_1.IncomeTaxType.GRADUATED) {
        if (!taxpayer) {
            throw new Error('Taxpayer info is required to initialize .');
        }
        if (!userID || typeof userID !== 'string' || userID.trim() === "") {
            throw new Error("User ID must be a non-empty string.");
        }
        if (!taxpayer.name || typeof taxpayer.name !== 'string' || taxpayer.name.trim() === "") {
            throw new Error("Taxpayer's Legal Name must be a non-empty string.");
        }
        if (!taxpayer.tin || typeof taxpayer.tin !== 'string' || taxpayer.tin.trim() === "") {
            throw new Error("Taxpayer's Registered TIN must be a non-empty string.");
        }
        if (!taxpayer.address || typeof taxpayer.address !== 'string' || taxpayer.address.trim() === "") {
            throw new Error("Taxpayer's Legal Address must be a non-empty string.");
        }
        if (!taxpayer.businessName || typeof taxpayer.businessName !== 'string' || taxpayer.businessName.trim() === "") {
            throw new Error("Taxpayer's Business Name must be a non-empty string.");
        }
        const currentYear = new Date().getFullYear();
        const safeYear = typeof year === 'number' ? year : currentYear;
        if (safeYear < 1800 || safeYear > 3000) {
            throw new Error(`Invalid year: ${safeYear}. Year must be between 1800 and 3000.`);
        }
        const defaultMetadata = {
            companyName: taxpayer.businessName || "Company XYZ",
            periodStart: "", // will be set by autoSetQuarterAndPeriod
            periodEnd: "", // will be set by autoSetQuarterAndPeriod
            quarter: quarter || enums_finance_1.QuarterPeriod.Q1, // default, but will be replaced
            year: safeYear || new Date().getFullYear(),
            currency: "PHP",
            generatedAt: new Date().toISOString(),
            generatedBy: userID || "SYSTEM",
            version: "1.0.0",
            invoiceCount: 0,
            incomeTaxType: incomeTaxType || enums_finance_1.IncomeTaxType.GRADUATED
        };
        // Instantiate the report
        const report = new SalesSummaryReport(undefined, defaultMetadata, undefined, [], userID, undefined, undefined);
        // Auto-set the correct quarter and date range
        return __classPrivateFieldGet(report, _SalesSummaryReport_instances, "m", _SalesSummaryReport_autoSetQuarterAndPeriod).call(report, quarter, safeYear);
    }
    /**
      * Sets the company name for the report.
      * @param name - Company name (non-empty string).
      * @returns The updated instance.
      */
    setCompanyName(name) {
        if (!name || typeof name !== 'string' || name.trim() === "") {
            throw new Error('Company name must be a non-empty string.');
        }
        this.metadata.companyName = name;
        return this;
    }
    /**
     * Sets the quarter period of the report.
     * @param quarter - Must be a valid QuarterPeriod enum value.
     * @returns The updated instance.
     */
    setQuarter(quarter) {
        if (!Object.values(enums_finance_1.QuarterPeriod).includes(quarter)) {
            throw new Error('Invalid quarter period.');
        }
        this.metadata.quarter = quarter;
        // Auto-sync periodStart & periodEnd with BIR quarter coverage.
        __classPrivateFieldGet(this, _SalesSummaryReport_instances, "m", _SalesSummaryReport_autoSetPeriodRange).call(this);
        return this;
    }
    /**
     * Sets the currency for the report.
     * @param currency - Must be a valid non-empty string (e.g., "PHP", "USD").
     * @returns The updated instance.
     */
    setCurrency(currency) {
        if (!currency || typeof currency !== 'string' || currency.trim() === "") {
            throw new Error('Currency must be a non-empty string.');
        }
        this.metadata.currency = currency.trim().toUpperCase();
        return this;
    }
    /**
     * Sets the income tax type.
     * @param taxType - Must be a valid IncomeTaxType enum value.
     * @returns The updated instance.
     */
    setIncomeTaxType(taxType) {
        if (!taxType || taxType.trim() === "") {
            throw new Error('Income Tax Type must be a non-empty string.');
        }
        this.metadata.incomeTaxType = taxType;
        return this;
    }
    /**
     * Sets the start period of the report.
     * @param dateStr - Must be a valid ISO date string.
     * @returns The updated instance.
     */
    setPeriodStart(dateStr) {
        const date = new Date(dateStr);
        if (isNaN(date.getTime())) {
            throw new Error('Invalid start date. Must be a valid ISO string.');
        }
        this.metadata.periodStart = dateStr;
        return this;
    }
    /**
     * Sets the end period of the report.
     * @param dateStr - Must be a valid ISO date string.
     * @returns The updated instance.
     */
    setPeriodEnd(dateStr) {
        const date = new Date(dateStr);
        if (isNaN(date.getTime())) {
            throw new Error('Invalid end date. Must be a valid ISO string.');
        }
        this.metadata.periodEnd = dateStr;
        return this;
    }
    /**
     * Approves the report and sets the approver's name.
     * @param approver - Must be a valid non-empty string.
     * @returns The updated instance.
     */
    approveReport(approver) {
        if (!approver || typeof approver !== 'string' || approver.trim() === "") {
            throw new Error('Approver name must be a non-empty string.');
        }
        this.metadata.approvedBy = approver;
        this.metadata.approvedAt = new Date().toISOString();
        this.status = ReportStatus.APPROVED;
        return this;
    }
    /**
     * Files the report. Only allowed if report has been approved.
     * @returns The updated instance.
     */
    fileReport() {
        if (this.status !== ReportStatus.APPROVED) {
            throw new Error('Report must be approved before it can be filed.');
        }
        this.status = ReportStatus.FILED;
        return this;
    }
    /**
     * Archives the report.
     * @returns The updated instance.
     */
    archiveReport() {
        this.status = ReportStatus.ARCHIVED;
        return this;
    }
    /**
     * Voids the report. Cannot void a report that is already voided.
     * @returns The updated instance.
     */
    voidReport() {
        if (this.status === ReportStatus.VOID) {
            throw new Error('Report is already voided.');
        }
        this.status = ReportStatus.VOID;
        return this;
    }
    /**
    * Checks if an invoice with the given ID exists in the report.
    * @param invoiceID - The invoice ID to check.
    * @returns true if the invoice exists, false otherwise.
    */
    doesInvoiceExist(invoiceID) {
        if (!invoiceID)
            return false;
        return this.invoices.some(invoice => invoice.id === invoiceID);
    }
    /**
    * Clears all existing invoices and resets the breakdown calculations.
    */
    clearInvoices() {
        this.invoices = [];
        this.metadata.invoiceCount = 0;
        __classPrivateFieldGet(this, _SalesSummaryReport_instances, "m", _SalesSummaryReport_resetBreakdown).call(this);
        return this;
    }
    /**
     * Removes an invoice from the report by its invoiceNumber.
     * @param invoiceNumber - The unique invoice number to remove.
     * @returns The updated SalesSummaryReport instance.
     * @throws Error if invoiceNumber is not found, invalid, or the invoice list is empty.
     */
    removeInvoiceByNumber(invoiceNumber) {
        if (!invoiceNumber || typeof invoiceNumber !== 'string' || invoiceNumber.trim() === '') {
            throw new Error("A valid non-empty invoiceNumber must be provided.");
        }
        if (!this.invoices || this.invoices.length === 0) {
            throw new Error("Invoice list is empty. Nothing to remove.");
        }
        const index = this.invoices.findIndex((inv) => inv.number === invoiceNumber);
        if (index === -1) {
            throw new Error(`Invoice with number "${invoiceNumber}" not found.`);
        }
        this.invoices.splice(index, 1);
        this.metadata.invoiceCount = this.invoices.length;
        return this;
    }
    /**
    * Overwrites existing invoices with a new set, resets totals, and recomputes breakdown.
    * @param input - Array of DigitalInvoice objects to replace current invoices.
    * @returns this - For chaining.
    */
    updateInvoices(input) {
        if (!Array.isArray(input) || input.length === 0) {
            throw new Error("Input must be a non-empty array of DigitalInvoice objects.");
        }
        // Replace invoices with fresh minimal refs
        this.invoices = input.map(invoice => ({
            id: invoice.id,
            number: invoice.metadata.invoiceNumber.toUpperCase(),
            timestamp: invoice.timestamp,
        }));
        // Update invoice count
        this.metadata.invoiceCount = this.invoices.length;
        // Reset totals before recomputing
        __classPrivateFieldGet(this, _SalesSummaryReport_instances, "m", _SalesSummaryReport_resetBreakdown).call(this);
        // Compute fresh totals based on new invoices
        __classPrivateFieldGet(this, _SalesSummaryReport_instances, "m", _SalesSummaryReport_computeBreakdown).call(this, input);
        return this;
    }
    /**
       * Add digital invoices to the report and update computed totals.
       * @param input - Array of DigitalInvoice objects
       */
    addInvoices(input) {
        if (!Array.isArray(input) || input.length === 0) {
            throw new Error("Input must be a non-empty array of DigitalInvoice objects.");
        }
        const existingIDs = new Set(this.invoices.map(inv => inv.number.toUpperCase()));
        const newRefs = input
            .filter(invoice => !existingIDs.has(invoice.metadata.invoiceNumber.toUpperCase()))
            .map(invoice => ({
            id: invoice.id,
            number: invoice.metadata.invoiceNumber.toUpperCase(),
            timestamp: invoice.timestamp,
        }));
        this.invoices.push(...newRefs);
        this.metadata.invoiceCount = this.invoices.length;
        __classPrivateFieldGet(this, _SalesSummaryReport_instances, "m", _SalesSummaryReport_computeBreakdown).call(this, input);
        return this;
    }
    /**
      * Converts the current `SalesSummaryReport` class to a plain JSON object and automatically generates an ID.
      * @returns {object} - A plain JSON object representation of the `SalesSummaryReport` with an autogenerated ID.
      */
    finalize(approvedBy) {
        this.status = ReportStatus.APPROVED;
        this.metadata.approvedBy = approvedBy;
        this.metadata.approvedAt = new Date().toISOString();
        return {
            id: autogenerateID(this.metadata.companyName),
            metadata: this.metadata,
            totals: this.totals,
            invoices: this.invoices,
            userID: this.userID,
            status: this.status,
            timestamp: this.timestamp
        };
    }
    /**
    * Converts the current `SalesSummaryReport` object to a plain JavaScript object (JSON).
    * @returns {object} - The plain object representation of the `SalesSummaryReport` instance.
    */
    toJSON() {
        return {
            id: this.id,
            metadata: this.metadata,
            totals: this.totals,
            invoices: this.invoices,
            userID: this.userID,
            status: this.status,
            timestamp: this.timestamp
        };
    }
    /**
    * Static method to parse a JSON string or object into a `SalesSummaryReport` instance.
    *
    * @param json - A JSON string or plain object to be parsed.
    * @returns {SalesSummaryReport} - A new `SalesSummaryReport` instance based on the parsed JSON.
    * @throws Will throw an error if required properties are missing.
    */
    static parseFromJSON(json) {
        const parsed = typeof json === 'string' ? JSON.parse(json) : json;
        if (!parsed.id) {
            throw new Error("Missing required property: 'id'");
        }
        if (!parsed.metadata || typeof parsed.metadata !== "object") {
            throw new Error("Missing or invalid report metadata.");
        }
        if (!parsed.metadata.quarter || !parsed.metadata.year) {
            throw new Error("Metadata must include both 'quarter' and 'year'.");
        }
        // Optional: validate required metadata fields more thoroughly
        const requiredMetadataFields = [
            "companyName",
            "periodStart",
            "periodEnd",
            "quarter",
            "year",
            "currency",
        ];
        for (const field of requiredMetadataFields) {
            if (!(field in parsed.metadata)) {
                throw new Error(`Missing required metadata field: ${field}`);
            }
        }
        const parsedTotals = {
            sales: finance_money_1.Money.parseFromJSON(parsed.totals.sales),
            discounts: {
                scPWD: finance_money_1.Money.parseFromJSON(parsed.totals.discounts.scPWD),
                other: finance_money_1.Money.parseFromJSON(parsed.totals.discounts.other),
                totalDiscount: finance_money_1.Money.parseFromJSON(parsed.totals.discounts.totalDiscount)
            },
            returns: finance_money_1.Money.parseFromJSON(parsed.totals.returns),
            taxableSales: finance_money_1.Money.parseFromJSON(parsed.totals.taxableSales),
            tax: {
                vat: finance_money_1.Money.parseFromJSON(parsed.totals.tax.vat),
                percentageTax: finance_money_1.Money.parseFromJSON(parsed.totals.tax.percentageTax),
                withholdingTax: finance_money_1.Money.parseFromJSON(parsed.totals.tax.withholdingTax),
                incomeTax: finance_money_1.Money.parseFromJSON(parsed.totals.tax.incomeTax),
            },
            netSales: finance_money_1.Money.parseFromJSON(parsed.totals.netSales),
            netIncome: finance_money_1.Money.parseFromJSON(parsed.totals.netIncome),
        };
        // Step 3: Create a new instance
        const report = new SalesSummaryReport(parsed.id, parsed.metadata, parsedTotals, parsed?.invoices || [], parsed?.userID, parsed?.status, parsed?.timestamp);
        return report;
    }
}
exports.SalesSummaryReport = SalesSummaryReport;
_SalesSummaryReport_instances = new WeakSet(), _SalesSummaryReport_computeBreakdown = function _SalesSummaryReport_computeBreakdown(invoices) {
    let grossSales = 0;
    let discSC = 0;
    let discOther = 0;
    let vatOutput = 0;
    let pctTax = 0;
    let whtTax = 0;
    let salesVatableOrPT = 0; // taxable-sales base
    for (const inv of invoices) {
        const b = inv.order.breakdown;
        const vatEntity = inv.metadata.type === business_invoice_1.InvoiceVATType.VAT;
        const nonVatEnt = inv.metadata.type === business_invoice_1.InvoiceVATType.NON_VAT;
        grossSales += b.totalSales; // usually VAT-inclusive
        discSC += b.discount.scPWD;
        discOther += b.discount.other;
        whtTax += b.withholdingTax.totalWithheldTax;
        salesVatableOrPT += b.vat.salesVATable + b.salesPT; // your schema already splits these
        if (vatEntity)
            vatOutput += b.vat.totalVAT;
        else if (nonVatEnt)
            pctTax += b.percentageTax.totalPercentageTax;
    }
    const totalDiscounts = discSC + discOther;
    const grossLessDisc = grossSales - totalDiscounts;
    /* -----------------------------------------------------------
     *  income-tax base
     * -----------------------------------------------------------
     * For GRADUATED: we assume no additional OPEX/COGS deductions
     * For FLAT 8 %  : BIR rule = (gross receipts – 250 k) × 8 %
     * (computeGraduatedIncomeTax already handles both types)
     */
    const incomeTaxType = this.metadata.incomeTaxType || enums_finance_1.IncomeTaxType.GRADUATED;
    const incomeTax = (0, utils_bir_tax_1.computeGraduatedIncomeTax)(grossLessDisc, incomeTaxType);
    console.log("Tax Type: ", incomeTaxType);
    /* -----------------------------------------------------------
     *  Net-sales and net-income logic
     * -----------------------------------------------------------
     *  - Pull out output-VAT from gross to get true revenue
     *  - Subtract percentage-tax if non-VAT (business expense)
     *  - Withholding tax is *not* an expense; it’s a credit.
     */
    let netSales = grossLessDisc;
    if (vatOutput)
        netSales -= vatOutput; // remove pass-through VAT
    if (pctTax)
        netSales -= pctTax; // percentage-tax expense
    const netIncome = netSales - incomeTax; // final profit
    const cur = this.metadata.currency;
    this.totals = {
        sales: new finance_money_1.Money(grossSales, cur),
        discounts: {
            totalDiscount: new finance_money_1.Money(totalDiscounts, cur),
            scPWD: new finance_money_1.Money(discSC, cur),
            other: new finance_money_1.Money(discOther, cur),
        },
        returns: new finance_money_1.Money(0, cur),
        taxableSales: new finance_money_1.Money(salesVatableOrPT, cur),
        tax: {
            vat: new finance_money_1.Money(vatOutput, cur),
            percentageTax: new finance_money_1.Money(pctTax, cur),
            withholdingTax: new finance_money_1.Money(whtTax, cur),
            incomeTax: new finance_money_1.Money(incomeTax, cur),
        },
        netSales: new finance_money_1.Money(netSales, cur),
        netIncome: new finance_money_1.Money(netIncome, cur),
    };
}, _SalesSummaryReport_resetBreakdown = function _SalesSummaryReport_resetBreakdown() {
    const cur = this.metadata.currency || "PHP";
    const zeroMoney = new finance_money_1.Money(0, cur);
    this.totals = {
        sales: zeroMoney,
        discounts: {
            totalDiscount: zeroMoney,
            scPWD: zeroMoney,
            other: zeroMoney,
        },
        returns: zeroMoney,
        taxableSales: zeroMoney,
        tax: {
            vat: zeroMoney,
            percentageTax: zeroMoney,
            withholdingTax: zeroMoney,
            incomeTax: zeroMoney,
        },
        netSales: zeroMoney,
        netIncome: zeroMoney,
    };
}, _SalesSummaryReport_autoSetQuarterAndPeriod = function _SalesSummaryReport_autoSetQuarterAndPeriod(quarter, year) {
    // If quarter/year passed, update metadata first
    if (quarter)
        this.metadata.quarter = quarter;
    if (year)
        this.metadata.year = year;
    // Use your imported getQuarterDateRange helper
    const [startDate, endDate] = (0, utils_finance_1.getQuarterDateRange)(this.metadata.quarter, this.metadata.year);
    this.metadata.periodStart = startDate.toISOString().split('T')[0];
    this.metadata.periodEnd = endDate.toISOString().split('T')[0];
    return this;
}, _SalesSummaryReport_autoSetPeriodRange = function _SalesSummaryReport_autoSetPeriodRange() {
    const baseYear = this.metadata.year.toString() ??
        new Date().getFullYear().toString();
    switch (this.metadata.quarter) {
        case enums_finance_1.QuarterPeriod.Q1:
            this.metadata.periodStart = `${baseYear}-01-01`;
            this.metadata.periodEnd = `${baseYear}-03-31`;
            break;
        case enums_finance_1.QuarterPeriod.Q2:
            this.metadata.periodStart = `${baseYear}-04-01`;
            this.metadata.periodEnd = `${baseYear}-06-30`;
            break;
        case enums_finance_1.QuarterPeriod.Q3:
            this.metadata.periodStart = `${baseYear}-07-01`;
            this.metadata.periodEnd = `${baseYear}-09-30`;
            break;
        case enums_finance_1.QuarterPeriod.Q4: // annual coverage (Oct-Dec for Q4 view)
            this.metadata.periodStart = `${baseYear}-10-01`;
            this.metadata.periodEnd = `${baseYear}-12-31`;
            break;
        default:
            throw new Error("Unrecognized quarter period.");
    }
};
/**
 * Generates a unique ID based on a given input string and the current Unix timestamp.
 * Used as a fallback when no ID is provided for the sales report.
 *
 * @param input - Item name or any descriptive string to use in the ID.
 * @returns A unique string identifier in the format: `sreport-[slug]-[timestamp]`
 */
function autogenerateID(input) {
    const unixTime = Math.floor(Date.now() / 1000);
    const titleText = input
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
    return `sreport-${titleText}-${unixTime}`;
}
